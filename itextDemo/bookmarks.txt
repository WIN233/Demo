第1章　Spring简介　1
1.1　实例化Spring IoC容器　1
1.1.1　问题　1
1.1.2　解决方案　1
1.1.3　工作原理　3
1.2　配置Spring IoC容器中的Bean　4
1.2.1　问题　4
1.2.2　解决方案　4
1.2.3　工作原理　4
1.3　调用构造程序创建Bean　14
1.3.1　问题　14
1.3.2　解决方案　14
1.3.3　工作原理　14
1.4　解决构造程序歧义　17
1.4.1　问题　17
1.4.2　解决方案　17
1.4.3　工作原理　17
1.5　指定Bean引用　20
1.5.1　问题　20
1.5.2　解决方案　20
1.5.3　工作原理　20
1.6　为集合元素指定数据类型　24
1.6.1　问题　24
1.6.2　解决方案　24
1.6.3　工作原理　24
1.7　使用Spring的FactoryBean创建Bean　27
1.7.1　问题　27
1.7.2　解决方案　27
1.7.3　工作原理　27
1.8　使用工厂Bean和Utility Schema定义集合　29
1.8.1　问题　29
1.8.2　解决方案　29
1.8.3　工作原理　29
1.9　用依赖检查属性　31
1.9.1　问题　31
1.9.2　解决方案　32
1.9.3　工作原理　32
1.10　用@Required注解检查属性　34
1.10.1　问题　34
1.10.2　解决方案　34
1.10.3　工作原理　34
1.11　用XML配置自动装配Bean　36
1.11.1　问题　36
1.11.2　解决方案　36
1.11.3　工作原理　37
1.12　用@Autowired和@Resource自动装配Bean　41
1.12.1　问题　41
1.12.2　解决方案　41
1.12.3　工作原理　41
1.13　继承Bean配置　47
1.13.1　问题　47
1.13.2　解决方案　47
1.13.3　工作原理　48
1.14　从Classpath中扫描组件　50
1.14.1　问题　50
1.14.2　解决方案　51
1.14.3　工作原理　51
1.15　小结　56

第2章　高级Spring IoC容器　57
2.1　调用静态工厂方法创建Bean　57
2.1.1　问题　57
2.1.2　解决方案　57
2.1.3　工作原理　57
2.2　调用一个实例工厂方法创建Bean　58
2.2.1　问题　58
2.2.2　解决方案　59
2.2.3　工作原理　59
2.3　从静态字段中声明Bean　60
2.3.1　问题　60
2.3.2　解决方案　60
2.3.3　工作原理　61
2.4　从对象属性中声明Bean　62
2.4.1　问题　62
2.4.2　解决方案　62
2.4.3　工作原理　62
2.5　使用Spring表达式语言　64
2.5.1　问题　64
2.5.2　解决方案　64
2.5.3　工作原理　65
2.6　设置Bean作用域　69
2.6.1　问题　69
2.6.2　解决方案　69
2.6.3　工作原理　70
2.7　自定义Bean初始化和析构　72
2.7.1　问题　72
2.7.2　解决方案　72
2.7.3　工作原理　72
2.8　用Java Config简化XML配置　77
2.8.1　问题　77
2.8.2　解决方案　77
2.8.3　工作原理　77
2.9　使Bean感知容器　81
2.9.1　问题　81
2.9.2　解决方案　81
2.9.3　工作原理　82
2.10　加载外部资源　82
2.10.1　问题　82
2.10.2　解决方案　83
2.10.3　工作原理　83
2.11　创建Bean后处理器　85
2.11.1　问题　85
2.11.2　解决方案　85
2.11.3　工作原理　86
2.12　外部化Bean配置　89
2.12.1　问题　89
2.12.2　解决方案　89
2.12.3　工作原理　90
2.13　解析文本消息　91
2.13.1　问题　91
2.13.2　解决方案　91
2.13.3　工作原理　91
2.14　使用应用事件进行通信　93
2.14.1　问题　93
2.14.2　解决方案　93
2.14.3　工作原理　94
2.15　在Spring中注册属性编辑器　96
2.15.1　问题　96
2.15.2　解决方案　96
2.15.3　工作原理　97
2.16　创建自定义属性编辑器　99
2.16.1　问题　99
2.16.2　解决方案　100
2.16.3　工作原理　100
2.17　使用TaskExecutor实现并发性　101
2.17.1　问题　101
2.17.2　解决方案　101
2.17.3　工作原理　102
2.18　小结　110

第3章　Spring AOP和AspectJ支持　112
3.1　启用Spring的AspectJ注解支持　113
3.1.1　问题　113
3.1.2　解决方案　113
3.1.3　工作原理　113
3.2　用AspectJ注解声明aspect　115
3.2.1　问题　115
3.2.2　解决方案　115
3.2.3　工作原理　116
3.3　访问连接点信息　121
3.3.1　问题　121
3.3.2　解决方案　122
3.3.3　工作原理　122
3.4　指定aspect优先级　123
3.4.1　问题　123
3.4.2　解决方案　123
3.4.3　工作原理　123
3.5　重用切入点定义　125
3.5.1　问题　125
3.5.2　解决方案　125
3.5.3　工作原理　125
3.6　编写AspectJ切入点表达式　127
3.6.1　问题　127
3.6.2　解决方案　127
3.6.3　工作原理　128
3.7　在你的Bean中引入行为　132
3.7.1　问题　132
3.7.2　解决方案　132
3.7.3　工作原理　132
3.8　为你的Bean引入状态　135
3.8.1　问题　135
3.8.2　解决方案　135
3.8.3　工作原理　135
3.9　用基于XML的配置声明aspect　137
3.9.1　问题　137
3.9.2　解决方案　137
3.9.3　工作原理　137
3.10　Spring中的AspectJ加载时织入aspect　140
3.10.1　问题　140
3.10.2　解决方案　141
3.10.3　工作原理　141
3.11　在Spring中配置AspectJ aspect　146
3.11.1　问题　146
3.11.2　解决方案　146
3.11.3　工作原理　146
3.12　将Spring Bean注入领域对象　147
3.12.1　问题　147
3.12.2　解决方案　147
3.12.3　工作原理　148
3.13　小结　151

第4章　Spring中的脚本　152
4.1　用脚本语言实现Bean　152
4.1.1　问题　152
4.1.2　解决方案　153
4.1.3　工作原理　153
4.2　将Spring Bean注入脚本中　157
4.2.1　问题　157
4.2.2　解决方案　157
4.2.3　工作原理　157
4.3　从脚本中刷新Bean　160
4.3.1　问题　160
4.3.2　解决方案　160
4.3.3　工作原理　160
4.4　定义内联脚本源码　161
4.4.1　问题　161
4.4.2　解决方案　161
4.4.3　工作原理　161
4.5　小结　163

第5章　Spring Security　164
5.1　加强URL访问安全　165
5.1.1　问题　165
5.1.2　解决方案　165
5.1.3　工作原理　166
5.2　登录到Web应用　175
5.2.1　问题　175
5.2.2　解决方案　175
5.2.3　工作原理　175
5.3　验证用户　179
5.3.1　问题　179
5.3.2　解决方案　180
5.3.3　工作原理　180
5.4　做出访问控制决策　190
5.4.1　问题　190
5.4.2　解决方案　190
5.4.3　工作原理　191
5.5　加强方法调用的安全　193
5.5.1　问题　193
5.5.2　解决方案　193
5.5.3　工作原理　194
5.6　处理视图中的安全性　196
5.6.1　问题　196
5.6.2　解决方案　196
5.6.3　工作原理　196
5.7　处理领域对象安全性　198
5.7.1　问题　198
5.7.2　解决方案　198
5.7.3　工作原理　199
5.8　小结　208

第6章　将Spring与其他Web框架集成　209
6.1　在一般Web应用中访问Spring　209
6.1.1　问题　209
6.1.2　解决方案　210
6.1.3　工作原理　210
6.2　在你的Servlet和过滤器中使用Spring　214
6.2.1　问题　214
6.2.2　解决方案　215
6.2.3　工作原理　215
6.3　将Spring与Struts 1.x集成　220
6.3.1　问题　220
6.3.2　解决方案　220
6.3.3　工作原理　220
6.4　将Spring与JSF集成　226
6.4.1　问题　226
6.4.2　解决方案　226
6.4.3　工作原理　227
6.5　将Spring与DWR集成　232
6.5.1　问题　232
6.5.2　解决方案　232
6.5.3　工作原理　233
6.6　小结　236

第7章　Spring Web Flow　238
7.1　用Spring Web Flow管理简单的UI流程　238
7.1.1　问题　238
7.1.2　解决方案　239
7.1.3　工作原理　239
7.2　用不同状态类型建立Web流程模型　246
7.2.1　问题　246
7.2.2　解决方案　246
7.2.3　工作原理　246
7.3　加强Web流程安全　257
7.3.1　问题　257
7.3.2　解决方案　258
7.3.3　工作原理　258
7.4　持续存储Web流程中的对象　260
7.4.1　问题　260
7.4.2　解决方案　260
7.4.3　工作原理　260
7.5　将Spring Web Flow与JSF集成　267
7.5.1　问题　267
7.5.2　解决方案　267
7.5.3　工作原理　267
7.6　使用RichFaces与Spring WebFlow协作　275
7.6.1　问题　275
7.6.2　解决方案　275
7.6.3　方法　275
7.7　小结　279

第8章　Spring @MVC　280
8.1　用Spring MVC开发简单的Web应用　280
8.1.1　问题　280
8.1.2　解决方案　281
8.1.3　工作原理　283
8.2　用@RequestMapping映射请求　293
8.2.1　问题　293
8.2.2　解决方案　294
8.2.3　工作原理　294
8.3　用处理程序拦截器拦截请求　297
8.3.1　问题　297
8.3.2　解决方案　298
8.3.3　工作原理　298
8.4　解析用户区域　302
8.4.1　问题　302
8.4.2　解决方案　302
8.4.3　工作原理　302
8.5　外部化区分区域的文本信息　304
8.5.1　问题　304
8.5.2　解决方案　304
8.5.3　工作原理　305
8.6　按照名称解析视图　306
8.6.1　问题　306
8.6.2　解决方案　306
8.6.3　工作原理　306
8.7　视图和内容协商　309
8.7.1　问题　309
8.7.2　解决方案　309
8.7.3　工作原理　309
8.8　映射异常视图　312
8.8.1　问题　312
8.8.2　解决方案　312
8.8.3　工作原理　312
8.9　用@Value在控制器中赋值　314
8.9.1　问题　314
8.9.2　解决方案　314
8.9.3　工作原理　314
8.10　用控制器处理表单　316
8.10.1　问题　316
8.10.2　解决方案　316
8.10.3　工作原理　317
8.11　用向导表单控制器处理多页表单　331
8.11.1　问题　331
8.11.2　解决方案　331
8.11.3　工作原理　332
8.12　使用注解(JSR-303)的Bean校验　341
8.12.1　问题　341
8.12.2　解决方案　342
8.12.3　工作原理　342
8.13　创建Excel和PDF视图　344
8.13.1　问题　344
8.13.2　解决方案　345
8.13.3　工作原理　345
8.14　小结　351

第9章　Spring REST　352
9.1　用Spring发布一个REST服务　352
9.1.1　问题　352
9.1.2　解决方案　353
9.1.3　工作原理　353
9.2　用Spring访问REST服务　358
9.2.1　问题　358
9.2.2　解决方案　358
9.2.3　工作原理　358
9.3　发布RSS和Atom信息源　362
9.3.1　问题　362
9.3.2　解决方案　363
9.3.3　工作原理　363
9.4　用REST服务发布JSON　372
9.4.1　问题　372
9.4.2　解决方案　372
9.4.3　工作原理　372
9.5　访问具有复杂XML响应的REST服务　375
9.5.1　问题　375
9.5.2　解决方案　375
9.5.3　工作原理　375
9.6　小结　385

第10章　Spring和Flex　386
10.1　Flex入门　388
10.1.1　问题　388
10.1.2　解决方案　388
10.1.3　工作原理　388
10.2　离开沙箱　393
10.2.1　问题　393
10.2.2　解决方案　394
10.2.3　工作原理　394
10.3　为应用添加Spring BlazeDS支持　406
10.3.1　问题　406
10.3.2　解决方案　406
10.3.3　工作原理　406
10.4　通过BlazeDS/Spring暴露服务　411
10.4.1　问题　411
10.4.2　解决方案　411
10.4.3　工作原理　411
10.5　使用服务器端对象　418
10.5.1　问题　418
10.5.2　解决方案　418
10.5.3　工作原理　418
10.6　使用BlazeDS和Spring消费面向消息的服务　421
10.6.1　问题　421
10.6.2　解决方案　422
10.6.3　工作原理　422
10.7　将依赖注入带给你的ActionScript客户　434
10.7.1　问题　434
10.7.2　解决方案　434
10.7.3　工作原理　435
10.8　小结　439

第11章　Grails　441
11.1　获取和安装Grails　441
11.1.1　问题　441
11.1.2　解决方案　442
11.1.3　工作原理　442
11.2　创建Grails应用　443
11.2.1　问题　443
11.2.2　解决方案　443
11.2.3　工作原理　443
11.3　Grails插件　447
11.3.1　问题　447
11.3.2　解决方案　448
11.3.3　工作原理　448
11.4　在Grails环境中开发、生产和测试　449
11.4.1　问题　449
11.4.2　解决方案　449
11.4.3　工作原理　450
11.5　创建应用的领域类　452
11.5.1　问题　452
11.5.2　解决方案　452
11.5.3　工作原理　452
11.6　为一个应用的领域类生成CRUD控制器和视图　454
11.6.1　问题　454
11.6.2　解决方案　454
11.6.3　工作原理　455
11.7　国际化(I18n)信息属性　458
11.7.1　问题　458
11.7.2　解决方案　458
11.7.3　工作原理　458
11.8　改变永久性存储系统　461
11.8.1　问题　461
11.8.2　解决方案　461
11.4.3　工作原理　461
11.9　日志　464
11.9.1　问题　464
11.9.2　解决方案　464
11.9.3　工作原理　464
11.10　运行单元和集成测试　466
11.10.1　问题　466
11.10.2　解决方案　467
11.10.3　工作原理　467
11.11　使用自定义布局和模板　472
11.11.1　问题　472
11.11.2　解决方案　472
11.11.3　工作原理　472
11.12　使用GORM查询　475
11.12.1　问题　475
11.12.2　解决方案　475
11.12.3　工作原理　475
11.13　创建自定义标记　477
11.13.1　问题　477
11.13.2　解决方案　477
11.13.3　工作原理　478
11.14　小结　479

第12章　Spring Roo　481
12.1　设置Spring Roo开发环境　483
12.1.1　问题　483
12.1.2　解决方案　483
12.1.3　工作原理　483
12.2　创建第一个Spring Roo项目　486
12.2.1　问题　486
12.2.2　解决方案　486
12.2.3　工作原理　486
12.3　把现有项目导入SpringSource Tool Suite　491
12.3.1　问题　491
12.3.2　解决方案　492
12.3.3　工作原理　492
12.4　更快地构建更好的应用程序　493
12.4.1　问题　493
12.4.2　解决方案　494
12.4.3　工作原理　494
12.5　从项目中删除Spring Roo　500
12.5.1　问题　500
12.5.2　解决方案　500
12.5.3　工作原理　501
12.6　小结　502

第13章　Spring测试　503
13.1　用JUnit and TestNG创建测试　504
13.1.1　问题　504
13.1.2　解决方案　504
13.1.3　工作原理　504
13.2　创建单元测试和集成测试　509
13.2.1　问题　509
13.2.2　解决方案　509
13.2.3　工作原理　510
13.3　Spring MVC控制器的单元测试　518
13.3.1　问题　518
13.3.2　解决方案　518
13.3.3 工作原理　518
13.4　管理集成测试中的应用上下文　520
13.4.1　问题　520
13.4.2　解决方案　520
13.4.3　工作原理　521
13.5　向集成测试注入测试夹具　526
13.5.1　问题　526
13.5.2　解决方案　526
13.5.3　工作原理　527
13.6　管理集成测试中的事务　530
13.6.1　问题　530
13.6.2　解决方案　530
13.6.3　工作原理　531
13.7　在集成测试中访问数据库　536
13.7.1　问题　536
13.7.2　解决方案　536
13.7.3　工作原理　537
13.8　使用Spring的常用测试注解　540
13.8.1　问题　540
13.8.2　解决方案　540
13.8.3　工作原理　541
13.9　小结　542

第14章　Spring Portlet MVC框架　544
14.1　用Spring Portlet MVC开发一个简单的Portlet　544
14.1.1　问题　544
14.1.2　解决方案　545
14.1.3　工作原理　546
14.2　将Portlet请求映射到处理程序　553
14.2.1　问题　553
14.2.2　解决方案　553
14.2.3　工作原理　554
14.3　用简单的表单控制器处理portlet表单　561
14.3.1　问题　561
14.3.2　解决方案　561
14.3.3　工作原理　561
14.4　小结　569

第15章　数据访问　570
15.1　Direct JDBC的问题　571
15.1.1　建立应用数据库　571
15.1.2　理解数据访问对象设计模式　573
15.1.3　用JDBC实现DAO　573
15.1.4　在Spring中配置数据源　575
15.1.5　运行DAO　577
15.1.6　更进一步　577
15.2　使用JDBC模板更新数据库　578
15.2.1　问题　578
15.2.2　解决方案　578
15.2.3　工作原理　578
15.3　使用JDBC模板查询数据库　583
15.3.1　问题　583
15.3.2　解决方案　583
15.3.3　工作原理　583
15.4　简化JDBC模板创建　588
15.4.1　问题　588
15.4.2　解决方案　588
15.4.3 工作原理　589
15.5　在Java 1.5中使用简单的JDBC模板　591
15.5.1　问题　591
15.5.2　解决方案　591
15.5.3　工作原理　591
15.6　在JDBC模板中使用命名参数　595
15.6.1　问题　595
15.6.2　解决方案　595
15.6.3　工作原理　595
15.7　在Spring JDBC框架中处理异常　597
15.7.1　问题　597
15.7.2　解决方案　597
15.7.3　工作原理　598
15.8　直接使用ORM框架的问题　602
15.8.1　问题　602
15.8.2　解决方案　603
15.8.3　工作原理　603
15.8.4　使用Hibernate API，用Hibernate XML映射持续化对象　604
15.8.5　使用Hibernate API，以JPA注解持续化对象　608
15.8.6　使用JPA，以Hibernate为引擎持续化对象　610
15.9　在Spring中配置ORM资源工厂　613
15.9.1　问题　613
15.9.2　解决方案　614
15.9.3　工作原理　614
15.10　用Spring ORM模板持续化对象　620
15.10.1　问题　620
15.10.2　解决方案　620
15.10.3　工作原理　621
15.11　用Hibernate的上下文会话持续化对象　626
15.11.1　问题　626
15.11.2　解决方案　626
15.11.3　工作原理　626
15.12　用JPA的上下文注入持续化对象　629
15.12.1　问题　629
15.12.2　解决方案　629
15.12.3　工作原理　630
15.13　小结　632

第16章　Spring中的事务管理　634
16.1　事务管理的问题　635
16.2　选择一个事务管理器实现　641
16.2.1　问题　641
16.2.2　解决方案　641
16.2.3　工作原理　641
16.3　用事务管理器API编程管理事务　642
16.3.1　问题　642
16.3.2　解决方案　643
16.3.3　工作原理　643
16.4　用事务模板编程管理事务　644
16.4.1　问题　644
16.4.2　解决方案　645
16.4.3　工作原理　645
16.5　用事务通知声明式地管理事务　647
16.5.1　问题　647
16.5.2　解决方案　648
16.5.3　工作原理　648
16.6　用@Transactional注解声明式地管理事务　650
16.6.1　方法　650
16.6.2　解决方案　650
16.6.3　工作原理　650
16.7　设置事务传播属性　652
16.7.1　问题　652
16.7.2　解决方案　652
16.7.3　工作原理　653
16.8　设置隔离事务属性　657
16.8.1　问题　657
16.8.2　解决方案　657
16.8.3　工作原理　658
16.9　设置Rollback事务属性　664
16.9.1　问题　664
16.9.2　解决方案　664
16.9.3　工作原理　664
16.10　设置超时和只读事务属性　666
16.10.1　问题　666
16.10.2　解决方案　666
16.10.3　工作原理　666
16.11　用加载时织入管理事务　667
16.11.1　问题　667
16.11.2　解决方案　667
16.11.3　工作原理　667
16.12　小结　671

第17章　EJB、Spring Remoting和Web服务　672
17.1　通过RMI暴露和调用服务　672
17.1.1　问题　672
17.1.2　解决方案　673
17.1.3　工作原理　673
17.2　用Spring创建EJB 2.x组件　676
17.2.1　问题　676
17.2.2　解决方案　677
17.2.3　工作原理　677
17.3　在Spring中访问遗留的EJB 2.x组件　683
17.3.1　问题　683
17.3.2　解决方案　683
17.3.3　工作原理　684
17.4　在Spring中创建EJB 3.0组件　687
17.4.1　问题　687
17.4.2　解决方案　687
17.4.3　工作原理　688
17.5　在Spring中访问EJB 3.0组件　689
17.5.1　问题　689
17.5.2　解决方案　690
17.5.3　工作原理　690
17.6　通过HTTP暴露和调用服务　692
17.6.1　问题　692
17.6.2　解决方案　692
17.6.3　工作原理　692
17.7　选择SOAP Web服务开发方法　696
17.7.1　问题　696
17.7.2　解决方案　696
17.7.3　工作原理　696
17.8　使用JAX-WS暴露和调用Contract-Last SOAP Web服务　698
17.8.1　问题　698
17.8.2　解决方案　698
17.8.3　工作原理　698
17.9　定义Web服务契约　705
17.9.1　问题　705
17.9.2　解决方案　705
17.9.3　工作原理　705
17.10　使用Spring-WS实现Web服务　709
17.10.1　问题　709
17.10.2　解决方案　709
17.10.3　工作原理　710
17.11　使用Spring-WS调用Web服务　715
17.11.1　问题　715
17.11.2　解决方案　715
17.11.3　工作原理　715
17.12　用XML编组开发Web服务　719
17.12.1　问题　719
17.12.2　解决方案　719
17.12.3　工作原理　720
17.13　用注解创建服务端点　724
17.13.1　问题　724
17.13.2　解决方案　725
17.13.3　工作原理　725
17.14　小结　726

第18章　企业中的Spring　727
18.1　将Spring Bean输出为JMX MBean　727
18.1.1　问题　727
18.1.2　解决方案　728
18.1.3　工作原理　728
18.2　发布和监听JMX通知　740
18.2.1　问题　740
18.2.2　解决方案　740
18.2.3　工作原理　740
18.3　在Spring中访问远程JMX MBean　742
18.3.1　问题　742
18.3.2　解决方案　742
18.3.3　工作原理　742
18.4　用Spring电子邮件支持发送邮件　745
18.4.1　问题　745
18.4.2　解决方案　745
18.4.3　工作原理　746
18.5　用Spring的Quartz支持进行调度　753
18.5.1　问题　753
18.5.2　解决方案　753
18.5.3　工作原理　753
18.6　用Spring 3.0的调度命名空间进行调度　758
18.6.1　问题　758
18.6.2　解决方案　758
18.6.3　工作原理　758
18.7　小结　762

第19章　消息　763
19.1　用Spring发送和接收JMS消息　764
19.1.1　问题　764
19.1.2　解决方案　765
19.1.3　工作原理　765
19.2　转换JMS消息　776
19.2.1　问题　776
19.2.2　解决方案　776
19.2.3　方法　776
19.3　管理JMS事务　778
19.3.1　问题　778
19.3.2　方法　779
19.3.3　解决方案　779
19.4　在Spring中创建消息驱动POJO　780
19.4.1　问题　780
19.4.2　解决方案　780
19.4.3　工作原理　781
19.5　建立连接　786
19.5.1　问题　786
19.5.2　解决方案　787
19.5.3　工作原理　787
19.6　小结　788

第20章　Spring Integration　789
20.1　用EAI集成一个系统到另一个系统　790
20.1.1　问题　790
20.1.2　解决方案　790
20.1.3　工作原理　790
20.2　使用JMS集成两个系统　793
20.2.1　问题　793
20.2.2　解决方案　793
20.2.3　工作原理　793
20.3　查询Spring Integration消息得到上下文信息　797
20.3.1　问题　797
20.3.2　解决方案　797
20.3.3　工作原理　797
20.4　用一个文件系统集成两个系统　800
20.4.1　问题　800
20.4.2　解决方案　800
20.4.3　工作原理　800
20.5　将消息从一种类型转换为另一种类型　802
20.5.1　问题　802
20.5.2　解决方案　802
20.5.3　工作原理　803
20.6　使用Spring Integration进行错误处理　806
20.6.1　问题　806
20.6.2　解决方案　806
20.6.3　工作原理　806
20.7　集成控制分支：分解器和聚合器　809
20.7.1　问题　809
20.7.2　解决方案　809
20.7.3　工作原理　809
20.8　用路由器实现条件路由　813
20.8.1　问题　813
20.8.2　解决方案　813
20.8.3　工作原理　813
20.9　使外部系统适应总线　814
20.9.1　问题　814
20.9.2　解决方案　814
20.9.3　工作原理　814
20.10　用Spring Batch产生事件　825
20.10.1　问题　825
20.10.2　解决方案　825
20.10.3　工作原理　825
20.11　使用网关　826
20.11.1　问题　826
20.11.2　解决方案　826
20.11.3　工作原理　827
20.12　小结　832

第21章　Spring Batch　834
21.1　建立Spring Batch的基础架构　836
21.1.1　问题　836
21.1.2　解决方案　836
21.1.3　工作原理　837
21.2　读取和写入(无计算)　839
21.2.1　问题　839
21.2.2　解决方案　839
21.2.3　工作原理　840
21.3　编写自定义ItemWriter和ItemReader　844
21.3.1　问题　844
21.3.2　解决方案　844
21.3.3　工作原理　844
21.4　在写入前处理输入　847
21.4.1　问题　847
21.4.2　解决方案　847
21.4.3　工作原理　847
21.5　通过事务改善生活　850
21.5.1　问题　850
21.5.2　解决方案　850
21.5.3　工作原理　850
21.6　重试　852
21.6.1　问题　852
21.6.2　解决方案　852
21.6.3　工作原理　852
21.7　控制步骤异常　855
21.7.1　问题　855
21.7.2　解决方案　856
21.7.3　工作原理　856
21.8　启动一个作业　860
21.8.1　问题　860
21.8.2　解决方案　860
21.8.3　工作原理　860
21.9　参数化一个作业　864
21.9.1　问题　864
21.9.2　解决方案　864
21.9.3　工作原理　864
21.10　小结　866

第22章　网格上的Spring　867
22.1　使用Terracotta聚合对象状态　869
22.1.1　问题　869
22.1.2　解决方案　869
22.1.3　工作原理　869
22.2　将执行分布到网格上　879
22.2.1　问题　879
22.2.2　解决方案　879
22.2.3　方法　879
22.3　方法的负载平衡　880
22.3.1　问题　880
22.3.2　解决方案　881
22.3.3　方法　881
22.4　并行处理　884
22.4.1　问题　884
22.4.2　解决方案　885
22.4.3　方法　885
22.5　在GridGain上部署　887
22.5.1　问题　887
22.5.2　解决方案　887
22.5.3　工作原理　887
22.6　小结　891

第23章　jBPM和Spring　893
软件过程　894
23.1　理解工作流模型　896
23.1.1　问题　896
23.1.2　解决方案　897
23.1.3　工作原理　897
23.2　安装jBPM　898
23.2.1　问题　898
23.2.2　解决方案　898
23.2.3　工作原理　898
23.3　将jBPM4与Spring整合　900
23.3.1　问题　900
23.3.2　解决方案　900
23.3.3　工作原理　900
23.4　用Spring构建一个服务　906
23.4.1　问题　906
23.4.2　解决方案　906
23.4.3　工作原理　907
23.5　构建业务过程　910
23.5.1　问题　910
23.5.2　解决方案　910
23.5.3　工作原理　910
23.6　小结　913

第24章　OSGi和Spring　914
24.1　OSGi入门　915
24.1.1　问题　915
24.1.2　解决方案　915
24.1.3　工作原理　916
24.2　开始使用Spring Dynamic Modules　922
24.2.1　问题　922
24.2.2　解决方案　922
24.2.3　工作原理　922
24.3　用Spring Dynamic Modules输出服务　926
24.3.1　问题　926
24.3.2　解决方案　926
24.3.3　工作原理　926
24.4　在OSGi注册表中寻找一个具体服务　929
24.4.1　问题　929
24.4.2　解决方案　930
24.4.3　工作原理　930
24.5　发布多个接口的一个服务　932
24.5.1　问题　932
24.5.2　解决方案　932
24.5.3　工作原理　932
24.6　定制Spring Dynamic Modules　933
24.6.1　问题　933
24.6.2　解决方案　933
24.6.3　工作原理　933
24.7　使用SpringSource dm Server　935
24.7.1　问题　935
24.7.2　解决方案　935
24.7.3　工作原理　935
24.8　SpringSource的各类工具　937
24.8.1　问题　937
24.8.2　解决方案　937
24.8.3　工作原理　937
24.9　小结　938
